<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hyper-Cycle: Arena</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
        }
        #hud {
            display: flex; justify-content: space-between; padding: 20px;
            font-size: 24px; font-weight: 900; text-transform: uppercase;
        }
        .p1-score { color: #00ffff; text-shadow: 0 0 15px #00ffff; }
        .p2-score { color: #ff0055; text-shadow: 0 0 15px #ff0055; }
        
        #game-over {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; display: none; pointer-events: auto;
            background: rgba(0,0,0,0.85); padding: 40px; border: 2px solid white;
            backdrop-filter: blur(5px);
        }
        h1 { margin: 0 0 10px 0; color: white; letter-spacing: 5px; font-style: italic; }
        p { color: #aaa; margin-bottom: 30px; }
        button {
            background: white; color: black; border: none; padding: 15px 40px;
            font-size: 18px; font-weight: bold; cursor: pointer; transition: 0.2s;
        }
        button:hover { background: #00ffff; box-shadow: 0 0 20px #00ffff; }
        
        /* Controls Hint */
        #controls {
            text-align: center; padding-bottom: 20px; color: rgba(255,255,255,0.4); font-size: 12px;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <div id="hud">
            <div class="p1-score">YOU</div>
            <div class="p2-score">CPU</div>
        </div>
        <div id="controls">ARROWS to Turn | SPACE to Boost</div>
    </div>

    <div id="game-over">
        <h1 id="winner-text">GAME OVER</h1>
        <p id="sub-text">System Failure</p>
        <button onclick="location.reload()">REMATCH</button>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURATION ---
        const GRID_SIZE = 80;
        const CELL_SIZE = 1;
        const SPEED_NORMAL = 0.05; // Movement per frame
        const MAX_TRAIL_LENGTH = 5000; // InstancedMesh limit

        let gameActive = true;
        
        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x050505, 0.035);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
        document.body.appendChild(renderer.domElement);

        // --- LIGHTS ---
        const ambient = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambient);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- THE GRID FLOOR ---
        const gridHelper = new THREE.GridHelper(GRID_SIZE, GRID_SIZE, 0x111111, 0x111111);
        gridHelper.position.y = -0.5;
        scene.add(gridHelper);
        
        // Floor Plane (for visual contrast)
        const planeGeo = new THREE.PlaneGeometry(GRID_SIZE * 4, GRID_SIZE * 4);
        planeGeo.rotateX(-Math.PI / 2);
        const planeMat = new THREE.MeshBasicMaterial({ color: 0x020202 });
        const floor = new THREE.Mesh(planeGeo, planeMat);
        floor.position.y = -0.6;
        scene.add(floor);

        // --- INSTANCED MESHES (For optimized trails) ---
        // This is the secret to high FPS. We create ONE mesh that draws 5000 cubes.
        const trailGeo = new THREE.BoxGeometry(1, 1, 1);
        const dummy = new THREE.Object3D(); // Helper to position instances

        // Player 1 Trail (Cyan)
        const p1Mat = new THREE.MeshStandardMaterial({ 
            color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 2.0 
        });
        const p1Trails = new THREE.InstancedMesh(trailGeo, p1Mat, MAX_TRAIL_LENGTH);
        p1Trails.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // Update often
        scene.add(p1Trails);

        // CPU Trail (Red)
        const p2Mat = new THREE.MeshStandardMaterial({ 
            color: 0xff0055, emissive: 0xff0055, emissiveIntensity: 2.0 
        });
        const p2Trails = new THREE.InstancedMesh(trailGeo, p2Mat, MAX_TRAIL_LENGTH);
        p2Trails.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        scene.add(p2Trails);

        // --- COLLISION MAP ---
        // A simple 2D array to track occupied cells: occupied[x][z] = true
        const collisionMap = new Map();

        function setOccupied(x, z) {
            collisionMap.set(`${Math.round(x)},${Math.round(z)}`, true);
        }

        function isOccupied(x, z) {
            // Check boundaries
            if (x > GRID_SIZE / 2 || x < -GRID_SIZE / 2 || z > GRID_SIZE / 2 || z < -GRID_SIZE / 2) return true;
            // Check map
            return collisionMap.has(`${Math.round(x)},${Math.round(z)}`);
        }

        // --- PLAYERS ---
        class Bike {
            constructor(color, x, z, dirX, dirZ, trailsMesh) {
                this.mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 0.5, 2),
                    new THREE.MeshStandardMaterial({ color: 0x222222 })
                );
                // Add glowing engine
                const engine = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.6, 1.5),
                    new THREE.MeshBasicMaterial({ color: color })
                );
                this.mesh.add(engine);
                
                this.mesh.position.set(x, 0, z);
                scene.add(this.mesh);

                this.dirX = dirX;
                this.dirZ = dirZ;
                this.nextDirX = dirX;
                this.nextDirZ = dirZ;
                
                this.speed = SPEED_NORMAL;
                this.trails = trailsMesh;
                this.trailCount = 0;
                this.lastGridPos = { x: x, z: z };
                this.dead = false;
                
                // Add a light to the bike
                this.light = new THREE.PointLight(color, 2, 15);
                this.light.position.set(0, 2, 0);
                this.mesh.add(this.light);
            }

            update() {
                if (this.dead) return;

                // 1. Move smooth
                this.mesh.position.x += this.dirX * this.speed * 4; // *4 arbitrary speed scale
                this.mesh.position.z += this.dirZ * this.speed * 4;

                // 2. Rotate Mesh
                if (this.dirX === 1) this.mesh.rotation.y = -Math.PI / 2;
                else if (this.dirX === -1) this.mesh.rotation.y = Math.PI / 2;
                else if (this.dirZ === 1) this.mesh.rotation.y = 0;
                else if (this.dirZ === -1) this.mesh.rotation.y = Math.PI;

                // 3. Grid Logic (Drop trail & Check Collision)
                const currentGridX = Math.round(this.mesh.position.x);
                const currentGridZ = Math.round(this.mesh.position.z);

                // Only perform logic if we moved to a NEW grid cell
                if (currentGridX !== this.lastGridPos.x || currentGridZ !== this.lastGridPos.z) {
                    
                    // A. Check Collision BEFORE placing wall
                    if (isOccupied(currentGridX, currentGridZ)) {
                        this.explode();
                        return;
                    }

                    // B. Place Wall in PREVIOUS spot (so we don't hit ourselves immediately)
                    this.addTrail(this.lastGridPos.x, this.lastGridPos.z);
                    setOccupied(this.lastGridPos.x, this.lastGridPos.z);

                    // C. Update Last Pos
                    this.lastGridPos.x = currentGridX;
                    this.lastGridPos.z = currentGridZ;
                    
                    // D. Apply Turn (Snap to grid center to prevent drift)
                    this.mesh.position.x = currentGridX;
                    this.mesh.position.z = currentGridZ;
                    this.dirX = this.nextDirX;
                    this.dirZ = this.nextDirZ;
                }
            }

            addTrail(x, z) {
                if (this.trailCount >= MAX_TRAIL_LENGTH) return;
                
                dummy.position.set(x, 0, z);
                dummy.updateMatrix();
                
                this.trails.setMatrixAt(this.trailCount++, dummy.matrix);
                this.trails.instanceMatrix.needsUpdate = true;
            }

            explode() {
                this.dead = true;
                this.mesh.visible = false;
                this.light.intensity = 0;
                createExplosion(this.mesh.position, this.light.color);
                checkGameOver();
            }
        }

        // --- INIT PLAYERS ---
        const player = new Bike(0x00ffff, -10, 0, 0, 1, p1Trails); // Starts Left, moving Down
        const bot = new Bike(0xff0055, 10, 0, 0, -1, p2Trails);   // Starts Right, moving Up

        // --- PARTICLES (EXPLOSION) ---
        const particleGeo = new THREE.BufferGeometry();
        const particleCount = 200;
        const posArray = new Float32Array(particleCount * 3);
        const velArray = []; // Store velocities

        for(let i=0; i<particleCount*3; i++) posArray[i] = 0;
        particleGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        
        const particleMat = new THREE.PointsMaterial({ size: 0.5, color: 0xffffff });
        const particles = new THREE.Points(particleGeo, particleMat);
        particles.visible = false;
        scene.add(particles);

        let explosionFrame = 0;
        
        function createExplosion(pos, color) {
            particles.visible = true;
            particles.material.color = color;
            explosionFrame = 60; // Run for 60 frames

            const positions = particles.geometry.attributes.position.array;
            
            for(let i=0; i < particleCount; i++) {
                // Reset positions to crash site
                positions[i*3] = pos.x;
                positions[i*3+1] = pos.y;
                positions[i*3+2] = pos.z;
                
                // Random velocities
                velArray[i] = {
                    x: (Math.random() - 0.5) * 1.5,
                    y: (Math.random() - 0.5) * 1.5 + 0.5, // Upward bias
                    z: (Math.random() - 0.5) * 1.5
                };
            }
        }

        function updateParticles() {
            if (explosionFrame <= 0) {
                particles.visible = false;
                return;
            }
            
            const positions = particles.geometry.attributes.position.array;
            for(let i=0; i < particleCount; i++) {
                positions[i*3] += velArray[i].x;
                positions[i*3+1] += velArray[i].y;
                positions[i*3+2] += velArray[i].z;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            explosionFrame--;
        }

        // --- BOT AI ---
        function updateBot() {
            if (bot.dead) return;

            // Simple raycast-like logic
            // Look ahead 2 steps
            const lookX = bot.lastGridPos.x + bot.dirX * 2;
            const lookZ = bot.lastGridPos.z + bot.dirZ * 2;

            // If danger ahead, turn!
            if (isOccupied(lookX, lookZ) || Math.random() < 0.02) { // 2% chance to turn randomly
                // Try Turning Left relative to current direction
                let leftX = 0, leftZ = 0;
                if (bot.dirZ === -1) { leftX = -1; } // Moving North -> Left is West
                else if (bot.dirZ === 1) { leftX = 1; } // Moving South -> Left is East
                else if (bot.dirX === -1) { leftZ = 1; } // Moving West -> Left is South
                else if (bot.dirX === 1) { leftZ = -1; } // Moving East -> Left is North

                const tryLeftX = bot.lastGridPos.x + leftX;
                const tryLeftZ = bot.lastGridPos.z + leftZ;

                if (!isOccupied(tryLeftX, tryLeftZ)) {
                    bot.nextDirX = leftX;
                    bot.nextDirZ = leftZ;
                } else {
                    // Left is blocked, try Right (opposite of Left)
                    bot.nextDirX = -leftX;
                    bot.nextDirZ = -leftZ;
                }
            }
        }

        // --- INPUTS ---
        window.addEventListener('keydown', (e) => {
            // Prevent scrolling
            if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].indexOf(e.code) > -1) {
                e.preventDefault();
            }

            if (e.key === 'ArrowUp' && player.dirZ !== 1) { player.nextDirX = 0; player.nextDirZ = -1; }
            if (e.key === 'ArrowDown' && player.dirZ !== -1) { player.nextDirX = 0; player.nextDirZ = 1; }
            if (e.key === 'ArrowLeft' && player.dirX !== 1) { player.nextDirX = -1; player.nextDirZ = 0; }
            if (e.key === 'ArrowRight' && player.dirX !== -1) { player.nextDirX = 1; player.nextDirZ = 0; }
        });

        function checkGameOver() {
            if (!gameActive) return;
            
            if (player.dead) {
                gameActive = false;
                document.getElementById('winner-text').innerText = "ELIMINATED";
                document.getElementById('winner-text').style.color = "#ff0055";
                document.getElementById('sub-text').innerText = "The CPU outsmarted you.";
                document.getElementById('game-over').style.display = 'block';
            } else if (bot.dead) {
                gameActive = false;
                document.getElementById('winner-text').innerText = "VICTORY";
                document.getElementById('winner-text').style.color = "#00ffff";
                document.getElementById('sub-text').innerText = "Target Destroyed.";
                document.getElementById('game-over').style.display = 'block';
            }
        }

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            if (gameActive) {
                updateBot();
                player.update();
                bot.update();
            }
            
            updateParticles();

            // Camera Follow Logic (Smooth)
            if (!player.dead) {
                const targetX = player.mesh.position.x;
                const targetZ = player.mesh.position.z + 15; // Behind
                const targetY = 20; // High up

                camera.position.x += (targetX - camera.position.x) * 0.1;
                camera.position.z += (targetZ - camera.position.z) * 0.1;
                camera.position.y += (targetY - camera.position.y) * 0.1;
                camera.lookAt(player.mesh.position);
            }

            renderer.render(scene, camera);
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>