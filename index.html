<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neon Roller 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui {
            position: absolute; top: 20px; left: 20px;
            color: #fff; font-size: 20px; font-weight: bold; pointer-events: none;
        }
        #status { color: #00ffcc; }
        #controls-hint {
            position: absolute; bottom: 20px; width: 100%;
            text-align: center; color: #888; pointer-events: none;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="ui">Level: 1 | Status: <span id="status">ALIVE</span></div>
    <div id="controls-hint">Use Arrow Keys to Move</div>

    <script type="module">
        import * as THREE from 'three';

        // --- SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x101015);
        
        // Camera (Isometric-ish view)
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 30, 40);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadows
        document.body.appendChild(renderer.domElement);

        // --- LIGHTS ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- GAME OBJECTS ---
        
        // 1. The Player (Ball)
        const playerRadius = 1;
        const playerGeo = new THREE.SphereGeometry(playerRadius, 32, 32);
        const playerMat = new THREE.MeshPhongMaterial({ color: 0x00ffcc, emissive: 0x004444 });
        const player = new THREE.Mesh(playerGeo, playerMat);
        player.castShadow = true;
        scene.add(player);

        // Physics State
        let velocity = { x: 0, y: 0, z: 0 };
        let onGround = false;
        const gravity = -0.5;
        const friction = 0.96; // 1 = ice, 0.8 = sand
        const speed = 0.8;

        // 2. The Level (Platforms)
        const platforms = [];
        
        function createPlatform(x, y, z, w, d, color = 0x444444) {
            const geo = new THREE.BoxGeometry(w, 1, d);
            const mat = new THREE.MeshPhongMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.receiveShadow = true;
            scene.add(mesh);
            
            // Store data for collision detection
            platforms.push({
                mesh: mesh,
                minX: x - w/2, maxX: x + w/2,
                minZ: z - d/2, maxZ: z + d/2,
                y: y + 0.5 // Top surface Y
            });
        }

        // Build Level 1
        createPlatform(0, -1, 0, 10, 10, 0x555555); // Start
        createPlatform(0, -1, -15, 4, 20, 0xaaaaaa); // Bridge
        createPlatform(-10, -1, -30, 15, 10, 0x555555); // Turn Left
        createPlatform(-15, -1, -50, 4, 30, 0xaaaaaa); // Long Bridge
        createPlatform(-15, -1, -75, 10, 10, 0x00ff00); // GOAL (Green)

        const goalZ = -75; // Z position of the goal

        // --- INPUT ---
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        window.addEventListener('keydown', (e) => keys[e.code] = true);
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. Apply Forces
            if (keys.ArrowUp) velocity.z -= speed * 0.1;
            if (keys.ArrowDown) velocity.z += speed * 0.1;
            if (keys.ArrowLeft) velocity.x -= speed * 0.1;
            if (keys.ArrowRight) velocity.x += speed * 0.1;

            // Apply Friction (Air resistance + rolling friction)
            velocity.x *= friction;
            velocity.z *= friction;

            // Apply Gravity
            velocity.y += gravity * 0.1;

            // 2. Move Player (Temporary Position)
            player.position.x += velocity.x;
            player.position.z += velocity.z;
            player.position.y += velocity.y;

            // 3. Collision Detection (Simple)
            onGround = false;
            
            // Check against every platform
            for (const plat of platforms) {
                // Are we above this platform horizontally?
                if (player.position.x >= plat.minX && player.position.x <= plat.maxX &&
                    player.position.z >= plat.minZ && player.position.z <= plat.maxZ) {
                    
                    // Are we touching the surface?
                    // (Check if we are falling through it)
                    if (player.position.y - playerRadius <= plat.y && player.position.y > plat.y - 1) {
                        player.position.y = plat.y + playerRadius; // Snap to top
                        velocity.y = 0;
                        onGround = true;
                    }
                }
            }

            // 4. Game Logic
            const statusEl = document.getElementById('status');

            // Fall Death
            if (player.position.y < -20) {
                statusEl.innerText = "FALLEN (Resetting...)";
                statusEl.style.color = "red";
                
                // Respawn Logic
                setTimeout(() => {
                    player.position.set(0, 2, 0);
                    velocity = { x: 0, y: 0, z: 0 };
                    statusEl.innerText = "ALIVE";
                    statusEl.style.color = "#00ffcc";
                }, 1000);
            }

            // Win Condition
            if (Math.abs(player.position.z - goalZ) < 5 && Math.abs(player.position.x + 15) < 5) {
                statusEl.innerText = "VICTORY!";
                player.material.emissive.setHex(0x00ff00);
            }

            // 5. Camera Follow (Smooth)
            // Camera trails slightly behind the player
            camera.position.x += (player.position.x - camera.position.x) * 0.1;
            camera.position.z += (player.position.z + 20 - camera.position.z) * 0.1;
            camera.lookAt(player.position);

            renderer.render(scene, camera);
        }

        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>